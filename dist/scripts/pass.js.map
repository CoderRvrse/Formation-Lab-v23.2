{
  "version": 3,
  "sources": ["../../scripts/pass.js"],
  "sourcesContent": ["// Pass module for Formation Lab\r\nimport { FLAB, AIM, aimState, headSpec, HEADS, PASS } from './state.js';\r\nimport { HEAD_OVERLAP, computeHeadScale } from './assets.arrows.js';\r\nimport { centerInField, fieldSize, clipSegmentToRect, getVar, insetFromA, insetFromB, viewToField } from './geometry.js';\r\nimport { playerEl, clearAimTags } from './render.js';\r\nimport { ensureHeadMarker, rebuildAllMarkers } from './pass.markers.js';\r\nimport { headPxFor, headTrimPx } from './pass.headsize.js';\r\nimport { getArrowSvg, ensureGroup } from './svgroot.js';\r\nimport { logPass } from './logger.js';\r\nimport { saveUndoState } from './undo-redo.js';\r\nimport { createArrowObject, findNearbyPlayer, getArrowStart, getArrowEnd } from './arrow-anchor.js';\r\n\r\n// Helper to get CSS variable in pixels\r\nfunction getVarPx(varName, fallback = 0) {\r\n  const val = getComputedStyle(document.documentElement).getPropertyValue(varName);\r\n  return parseFloat(val) || fallback;\r\n}\r\n\r\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\r\nconst PASS_STYLES = ['solid', 'comic-flat', 'comic-halftone'];\r\n\r\n// Hardened number utilities\r\nfunction safeNumber(v, def=0) {\r\n  if (typeof v === 'number' && Number.isFinite(v)) return v;\r\n  if (typeof v === 'string') {\r\n    const n = parseFloat(v);\r\n    return Number.isFinite(n) ? n : def;\r\n  }\r\n  return def;\r\n}\r\n\r\n// Use overlap values from asset specifications\r\nfunction headOverlapFor(style){ return headSpec(style).overlap ?? 2; }\r\n\r\n/**\r\n * Positions and rotates a head group so its base sits at the end of `shaftPath`,\r\n * oriented along the path tangent. Uses small overlap to hide seams.\r\n *\r\n * @param {SVGPathElement} shaftPath - the visible shaft (<path>) on screen\r\n * @param {SVGGElement} headGroup     - the group containing the head graphic\r\n * @param {string} style              - current pass style (solid/comic-flat/comic-halftone)\r\n */\r\nexport async function attachPassHead(shaftPath, style) {\r\n  if (!shaftPath) return;\r\n\r\n  const L = shaftPath.getTotalLength();\r\n  const overlap = (HEAD_OVERLAP?.[style] ?? 2);\r\n\r\n  // headBaseLen is exactly where the ball stops too\r\n  const baseLen = Math.max(0, L - overlap);\r\n  shaftPath.dataset.headBaseLen = String(baseLen);\r\n\r\n  // Use the clean simple-markers system with improved error handling\r\n  const { attachHead } = await import('../assets/arrows/simple-markers.js');\r\n\r\n  try {\r\n    // attachHead now handles all timing internally with retries\r\n    const result = await attachHead(shaftPath, `head-${style}`);\r\n    if (result instanceof Promise) {\r\n      await result;\r\n    }\r\n    console.log(`\uD83C\uDFAF Head attached: style=${style}, baseLen=${baseLen.toFixed(1)}px`);\r\n  } catch (error) {\r\n    // For preview paths that might not be fully attached, try silent fallback\r\n    try {\r\n      if (shaftPath.setAttribute) {\r\n        shaftPath.setAttribute('marker-end', `url(#head-${style})`);\r\n        shaftPath.setAttribute('vector-effect', 'non-scaling-stroke');\r\n        console.log(`\uD83C\uDFAF Head attached (silent fallback): style=${style}`);\r\n      }\r\n    } catch (fallbackError) {\r\n      // Even fallback failed - this is likely a preview path that will be recreated\r\n      console.debug(`\u26A1 Preview path attachment skipped: ${error.message}`);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Ensures the SVG markers are available for the given style\r\n * @param {string} style - pass style (solid, comic-flat, comic-halftone)\r\n */\r\nfunction ensurePassMarker(style) {\r\n  const svg = document.getElementById('arrow-layer');\r\n  if (!svg) return;\r\n\r\n  const marker = svg.querySelector(`#head-${style}`);\r\n  if (marker) return; // already exists\r\n\r\n  // Import and trigger marker creation if needed\r\n  import('./assets.arrows.js').then(({ preloadArrowHeads }) => {\r\n    preloadArrowHeads();\r\n  });\r\n}\r\n\r\n/**\r\n * Finalizes head positioning after shaft updates\r\n * @param {SVGGElement} passGroup - the pass group containing shaft and head\r\n * @param {string} style - current pass style\r\n */\r\nfunction finalizeHead(passGroup, style = FLAB.passStyle) {\r\n  if (!passGroup) return;\r\n\r\n  const shaft = passGroup.querySelector('.pass-shaft');\r\n  if (!shaft) return;\r\n\r\n  // Remove any old head groups - we're using markers now\r\n  const oldHead = passGroup.querySelector('.pass-head');\r\n  if (oldHead) {\r\n    oldHead.remove();\r\n  }\r\n\r\n  // Ensure marker exists and attach to shaft\r\n  ensurePassMarker(style);\r\n  attachPassHead(shaft, style);\r\n}\r\n\r\n// Precision endpoint computation for field-local coordinates\r\nfunction unit(ax, ay, bx, by) {\r\n  const dx = bx - ax, dy = by - ay;\r\n  const d = Math.hypot(dx, dy) || 1;\r\n  return { ux: dx / d, uy: dy / d, d };\r\n}\r\n\r\n// Helper functions\r\nfunction getPlayer(playerId) {\r\n  return FLAB.players.find(player => player.id === playerId) || null;\r\n}\r\n\r\nfunction getPlayerEl(playerId) {\r\n  return document.querySelector(`.player[data-id=\"${playerId}\"]`);\r\n}\r\n\r\nfunction snapHalf(p) {\r\n  p.x = Math.round(p.x) + 0.5;\r\n  p.y = Math.round(p.y) + 0.5;\r\n  return p;\r\n}\r\n\r\nfunction haloRadiusPx() {\r\n  const h = document.getElementById('flabHalo');\r\n  return ((h?.offsetWidth) || 56) / 2;\r\n}\r\n\r\nfunction tokenRadiusPx(el) {\r\n  // jersey button size \u2248 its min dimension /2; fallback to 28\r\n  const r = el?.getBoundingClientRect();\r\n  return Math.max(14, Math.min(r?.width || 56, r?.height || 56) / 2);\r\n}\r\n\r\n// Helper to get player view coordinates\r\nfunction getPlayerViewCoords(player) {\r\n  const el = document.querySelector(`.player[data-id=\"${player.id}\"]`);\r\n  if (!el) return null;\r\n\r\n  const rect = el.getBoundingClientRect();\r\n  const fieldRect = document.getElementById('pitchMount').getBoundingClientRect();\r\n  return {\r\n    x: rect.left + rect.width / 2 - fieldRect.left,\r\n    y: rect.top + rect.height / 2 - fieldRect.top\r\n  };\r\n}\r\n\r\n// Find nearest player in view space (exclude passer)\r\nfunction nearestPlayerView(x, y, excludeId) {\r\n  let best = null, bestDist = Infinity;\r\n  for (const p of FLAB.players) {\r\n    if (p.id === excludeId) continue;\r\n    const pView = getPlayerViewCoords(p);\r\n    if (!pView) continue;\r\n    const d = Math.hypot(pView.x - x, pView.y - y);\r\n    if (d < bestDist) {\r\n      best = p;\r\n      bestDist = d;\r\n    }\r\n  }\r\n  return { player: best, dist: bestDist };\r\n}\r\n\r\nexport function computePassEndpoints(passerEl, targetEl) {\r\n  const startGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--pass-origin-gap')) || 1.5;\r\n  const endGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--pass-target-gap')) || 2;\r\n\r\n  // Centers in **field-local** pixels\r\n  const A0 = centerInField(passerEl);\r\n  const B0 = centerInField(targetEl);\r\n\r\n  const startInset = haloRadiusPx() + startGap;\r\n  const endInset = tokenRadiusPx(targetEl) + endGap;\r\n\r\n  let A = insetFromA(A0.x, A0.y, B0.x, B0.y, startInset);\r\n  let B = insetFromB(A0.x, A0.y, B0.x, B0.y, endInset);\r\n\r\n  // Minimum visible length guard\r\n  const { d, ux, uy } = unit(A.x, A.y, B.x, B.y);\r\n  const minLen = 12;\r\n  if (d < minLen) {\r\n    const cx = (A.x + B.x) / 2, cy = (A.y + B.y) / 2, half = minLen / 2;\r\n    A = { x: cx - ux * half, y: cy - uy * half };\r\n    B = { x: cx + ux * half, y: cy + uy * half };\r\n  }\r\n\r\n  return { A: snapHalf(A), B: snapHalf(B) };\r\n}\r\n\r\n// Compute clipped pass endpoints that stay within field bounds\r\nexport function computeClippedPass(A, B) {\r\n  const { w, h } = fieldSize();\r\n  const seg = clipSegmentToRect(A.x, A.y, B.x, B.y, w, h);\r\n  if (!seg.visible) return null; // nothing to draw\r\n  return { A: snapHalf({x: seg.ax, y: seg.ay}), B: snapHalf({x: seg.bx, y: seg.by}) };\r\n}\r\n\r\nfunction applyPassStyle(el, lengthPx = null) {\r\n  const s = FLAB.passStyle;\r\n  const cls = s.startsWith('comic') ? 'pass-comic' : 'pass-solid';\r\n  el.setAttribute('class', cls);\r\n\r\n  // Use length-aware markers if length is provided\r\n  if (lengthPx !== null) {\r\n    const arrowLayer = document.getElementById('arrow-layer');\r\n    const defs = arrowLayer?.querySelector('defs');\r\n    if (defs) {\r\n      const markerId = ensureHeadMarker(defs, s, lengthPx);\r\n      if (markerId) {\r\n        el.setAttribute('marker-end', `url(#${markerId})`);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Fallback to static markers\r\n  const markerId = s === 'solid' ? 'passHead-solid' : s === 'comic-flat' ? 'passHead-comic-flat' : 'passHead-comic-halftone';\r\n  el.setAttribute('marker-end', `url(#${markerId})`);\r\n}\r\n\r\n// Set arrow paths with clean shaft-head join\r\nfunction setArrowPaths(svgGroup, A, Btip, styleKey, lenPx, shaftClass) {\r\n  if (!svgGroup) return;\r\n  console.debug('setArrowPaths', A, Btip, svgGroup?.ownerSVGElement?.id);\r\n\r\n  // Debug shaft disabled - using main shaft with CSS styling instead\r\n  // let shaft = svgGroup.querySelector('path.__debug');\r\n  // if (!shaft) {\r\n  //   shaft = document.createElementNS('http://www.w3.org/2000/svg','path');\r\n  //   shaft.setAttribute('class','__debug');\r\n  //   svgGroup.appendChild(shaft);\r\n  // }\r\n  // shaft.setAttribute('d', `M ${A.x} ${A.y} L ${Btip.x} ${Btip.y}`);\r\n  // shaft.setAttribute('fill','none');\r\n  // shaft.setAttribute('stroke', PASS.color || '#ffd166');\r\n  // shaft.setAttribute('stroke-width', FLAB.passWidth || 4);\r\n  // shaft.setAttribute('vector-effect','non-scaling-stroke');\r\n\r\n  const svgRoot = getArrowSvg();\r\n  const arrowGroup = document.getElementById('arrow-group');\r\n  if (!svgRoot || !arrowGroup) {\r\n    console.warn('setArrowPaths: no arrow SVG root or arrow-group');\r\n    return;\r\n  }\r\n\r\n  // If group is not in DOM or not under arrow-group, reattach it\r\n  if (!svgGroup || svgGroup.parentNode !== arrowGroup) {\r\n    if (!svgGroup) {\r\n      svgGroup = document.createElementNS(svgRoot.namespaceURI,'g');\r\n    }\r\n    arrowGroup.appendChild(svgGroup);\r\n  }\r\n\r\n  const defs = svgRoot.querySelector('defs'); // guaranteed by getArrowSvg()\r\n  const headId = ensureHeadMarker(defs, styleKey, lenPx);\r\n  const headPx = headPxFor(lenPx, /comic/.test(styleKey));\r\n  const trim = headTrimPx(headPx);\r\n\r\n  // Compute Bshaft = Btip moved back toward A by trim\r\n  const dx = Btip.x - A.x;\r\n  const dy = Btip.y - A.y;\r\n  const L = Math.hypot(dx, dy) || 1;\r\n  const Bshaft = {\r\n    x: Btip.x - dx * (trim / L),\r\n    y: Btip.y - dy * (trim / L)\r\n  };\r\n\r\n  // Clear previous content except debug shaft\r\n  Array.from(svgGroup.children).forEach(child => {\r\n    if (!child.classList.contains('shaft')) {\r\n      svgGroup.removeChild(child);\r\n    }\r\n  });\r\n\r\n  // 1) Visible shaft path (stops at Bshaft) - DIRECT COLOR APPLICATION\r\n  const mainShaft = document.createElementNS(SVG_NS, 'path');\r\n  mainShaft.classList.add('pass-shaft');\r\n  mainShaft.classList.add(shaftClass);\r\n  mainShaft.classList.add(`pass-${styleKey}`);\r\n  mainShaft.dataset.passStyle = styleKey;\r\n  mainShaft.setAttribute('vector-effect', 'non-scaling-stroke');\r\n  mainShaft.setAttribute('fill', 'none');\r\n  mainShaft.setAttribute('d', `M ${A.x} ${A.y} L ${Bshaft.x} ${Bshaft.y}`);\r\n\r\n  // Get color from multiple sources in priority order\r\n  let currentColor = '#ffd166'; // fallback\r\n\r\n  // Try CSS variable first\r\n  const cssVar = getComputedStyle(document.documentElement).getPropertyValue('--pass-color').trim();\r\n  if (cssVar) {\r\n    currentColor = cssVar;\r\n  }\r\n\r\n  // Try PASS.color if available\r\n  if (PASS?.color) {\r\n    currentColor = PASS.color;\r\n  }\r\n\r\n  // FORCE CSS VARIABLE UPDATE - This ensures the CSS variable is updated before creating shaft\r\n  document.documentElement.style.setProperty('--pass-color', currentColor);\r\n\r\n  // Also ensure PASS.color is synchronized\r\n  if (PASS) {\r\n    PASS.color = currentColor;\r\n  }\r\n\r\n  mainShaft.setAttribute('stroke', currentColor);\r\n  mainShaft.style.stroke = currentColor;\r\n  mainShaft.style.color = currentColor;\r\n  mainShaft.setAttribute('color', currentColor);\r\n\r\n  // Add shaft to DOM first so CSS rules can apply\r\n  svgGroup.appendChild(mainShaft);\r\n\r\n  // FORCE IMMEDIATE CSS RECALCULATION\r\n  // Since CSS has !important rules that override inline styles, we need to ensure the CSS variable is read correctly\r\n  getComputedStyle(mainShaft).stroke; // Force style calculation\r\n\r\n  // Ensure comic style uses solid stroke by clearing any dash pattern\r\n  if (shaftClass === 'pass-comic') {\r\n    mainShaft.removeAttribute('stroke-dasharray');\r\n  }\r\n\r\n  // DETAILED DEBUGGING - Check what actually got set AND monitor changes\r\n  let monitorCount = 0;\r\n  const monitorChanges = () => {\r\n    monitorCount++;\r\n    const actualStroke = mainShaft.getAttribute('stroke');\r\n    const computedStroke = getComputedStyle(mainShaft).stroke;\r\n    const hasStyleStroke = mainShaft.style.stroke;\r\n    console.log(`\uD83D\uDD0D SHAFT DEBUG (check ${monitorCount}):`);\r\n    console.log(`  - Intended color: ${currentColor}`);\r\n    console.log(`  - SVG stroke attribute: ${actualStroke}`);\r\n    console.log(`  - Computed stroke style: ${computedStroke}`);\r\n    console.log(`  - Inline style.stroke: ${hasStyleStroke}`);\r\n\r\n    if (monitorCount < 5) {\r\n      setTimeout(monitorChanges, 200); // Check again in 200ms\r\n    }\r\n\r\n    if (monitorCount === 1) {\r\n      console.log(`  - Element:`, mainShaft);\r\n    }\r\n  };\r\n\r\n  setTimeout(monitorChanges, 100);\r\n\r\n  // MUTATION OBSERVER - Watch for any changes to the shaft element\r\n  const observer = new MutationObserver((mutations) => {\r\n    mutations.forEach((mutation) => {\r\n      if (mutation.type === 'attributes' && (mutation.attributeName === 'stroke' || mutation.attributeName === 'style')) {\r\n        console.log(`\uD83D\uDEA8 SHAFT MODIFIED by external code!`);\r\n        console.log(`  - Attribute changed: ${mutation.attributeName}`);\r\n        console.log(`  - New value: ${mainShaft.getAttribute(mutation.attributeName)}`);\r\n        console.log(`  - Current computed stroke: ${getComputedStyle(mainShaft).stroke}`);\r\n      }\r\n    });\r\n  });\r\n\r\n  observer.observe(mainShaft, {\r\n    attributes: true,\r\n    attributeFilter: ['stroke', 'style']\r\n  });\r\n\r\n  // Stop observing after 5 seconds\r\n  setTimeout(() => observer.disconnect(), 5000);\r\n\r\n  console.log(`\u2705 Shaft created with direct color: ${currentColor} (CSS: ${cssVar}, PASS: ${PASS?.color}), style: ${shaftClass}`);\r\n\r\n  // 2) Attach marker-based head to shaft\r\n  ensurePassMarker(styleKey);\r\n  attachPassHead(mainShaft, styleKey);\r\n\r\n  // Dash polish: ensure last dash doesn't peek under the head\r\n  mainShaft.style.strokeDashoffset = '';\r\n  mainShaft.style.strokeLinecap = 'butt';\r\n}\r\n\r\n\r\nfunction createPass(arrow) {\r\n  const { id, fromId, to, curved = false, control = null } = arrow;\r\n\r\n  const startPlayer = getPlayer(fromId);\r\n  if (!startPlayer) return null;\r\n\r\n  // Get DOM elements for precise field-local coordinates\r\n  const passerEl = document.querySelector(`.player[data-id=\"${fromId}\"]`);\r\n  if (!passerEl) return null;\r\n\r\n  // NEW: Use anchor system to compute proper visual endpoints\r\n  // This ensures arrows follow players and snap cleanly to target player edges\r\n  const arrowStart = getArrowStart(fromId);\r\n  const arrowEnd = getArrowEnd(arrow);\r\n\r\n  if (!arrowStart || !arrowEnd) return null;\r\n\r\n  // Create a temporary element at computed endpoint for field calculations\r\n  const tempTarget = document.createElement('div');\r\n  tempTarget.style.cssText = `position:absolute;left:${arrowEnd.x}px;top:${arrowEnd.y}px;width:56px;height:56px;pointer-events:none;`;\r\n  document.querySelector('.flab-field').appendChild(tempTarget);\r\n\r\n  try {\r\n    // Use field-local precise endpoints\r\n    const { A, B } = computePassEndpoints(passerEl, tempTarget);\r\n\r\n    let pathData;\r\n    if (curved && control) {\r\n      // For curved passes, use the tight endpoints but keep the control point\r\n      const safeControlX = safeNumber(control.x, (A.x + B.x) / 2);\r\n      const safeControlY = safeNumber(control.y, (A.y + B.y) / 2);\r\n      pathData = `M ${A.x} ${A.y} Q ${safeControlX} ${safeControlY} ${B.x} ${B.y}`;\r\n    } else {\r\n      // For straight passes with clipping\r\n      const clipped = computeClippedPass(A, B);\r\n      if (clipped) {\r\n        pathData = `M ${clipped.A.x} ${clipped.A.y} L ${clipped.B.x} ${clipped.B.y}`;\r\n      } else {\r\n        pathData = \"\"; // Nothing to draw - completely outside field\r\n      }\r\n    }\r\n\r\n    // Only proceed if all coordinates are finite\r\n    if (!pathData.match(/NaN|Infinity|-Infinity/)) {\r\n\r\n      // Calculate pass length for size-aware markers\r\n      const lengthPx = Math.hypot(B.x - A.x, B.y - A.y);\r\n      const styleKey = FLAB.passStyle;\r\n      const shaftClass = styleKey.startsWith('comic') ? 'pass-comic' : 'pass-solid';\r\n\r\n      const group = document.createElementNS(SVG_NS, \"g\");\r\n      group.setAttribute(\"data-arrow-id\", String(id));\r\n      group.classList.add(\"svg-pass\");\r\n\r\n      // Use the new clean shaft-head join system\r\n      setArrowPaths(group, A, B, styleKey, lengthPx, shaftClass);\r\n\r\n      // Create hitbox for the full path\r\n      const hitbox = document.createElementNS(SVG_NS, \"path\");\r\n      hitbox.setAttribute(\"d\", pathData);\r\n      hitbox.classList.add(\"flab-arrow-hitbox\");\r\n      group.appendChild(hitbox);\r\n\r\n      return group;\r\n    } else {\r\n      console.warn('Rejected path with invalid coordinates:', pathData);\r\n      return null;\r\n    }\r\n  } finally {\r\n    // Clean up temporary target element\r\n    tempTarget.remove();\r\n  }\r\n}\r\n\r\n// called on pointerdown in Pass mode\r\nexport function beginPassPreview(passer) {\r\n  FLAB.passArm = { drawing: true, curved: false, latest: getPlayerViewCoords(passer) };\r\n  FLAB.activePlayer = passer;\r\n  FLAB.aim.candidateId = null;\r\n  FLAB.aim.lockedId = null;\r\n  FLAB.aim.showAt = 0;\r\n  clearAimTags();\r\n  FLAB.previewG = ensureGroup('pass-preview');\r\n  while (FLAB.previewG.firstChild) FLAB.previewG.removeChild(FLAB.previewG.firstChild);\r\n}\r\n\r\n// Helper to get shaft class for pass style\r\nfunction shaftClassFor(style) {\r\n  return style.startsWith('comic') ? 'pass-comic' : 'pass-solid';\r\n}\r\n\r\n// commit pass on pointerup\r\nexport function commitPass() {\r\n  if (!FLAB.passArm?.drawing) return;\r\n  const passer = FLAB.activePlayer;\r\n  if (!passer) return;\r\n\r\n  const cur = FLAB.passArm.latest;\r\n  const tgtGap = getVarPx('--pass-target-gap', 2);\r\n  const passerView = getPlayerViewCoords(passer);\r\n\r\n  let endV = cur;\r\n  if (FLAB.aim.lockedId) {\r\n    const t = getPlayer(FLAB.aim.lockedId);\r\n    const tView = getPlayerViewCoords(t);\r\n    if (passerView && tView) {\r\n      const targetR = 28;\r\n      endV = insetFromB(passerView.x, passerView.y, tView.x, tView.y, targetR + tgtGap);\r\n    }\r\n  }\r\n\r\n  commitArrow(passer.id, endV, FLAB.passArm.curved, FLAB.passArm.control);\r\n\r\n  // telemetry: log pass details for dev/analytics\r\n  const startField = viewToField(passerView);\r\n  const endField = viewToField(endV);\r\n\r\n  const style = FLAB.passStyle;\r\n  const width = FLAB.passWidth;\r\n  const color = PASS.color || '#ffd166';\r\n  const curved = !!FLAB.passArm?.curved;\r\n\r\n  const fromId = passer.id;\r\n  const fromNum = passer.number ?? passer.id;\r\n\r\n  // if we had a lock, we know the receiver; else \"free\" end (toId=null)\r\n  const lockedId = FLAB.aim?.lockedId ?? null;\r\n  const target = lockedId ? getPlayer(lockedId) : null;\r\n  const toId = target?.id ?? null;\r\n  const toNum = target?.number ?? target?.id ?? null;\r\n\r\n  const dx = endV.x - passerView.x;\r\n  const dy = endV.y - passerView.y;\r\n  const lengthPx = Math.hypot(dx, dy);\r\n\r\n  logPass({\r\n    fromId, toId, fromNum, toNum,\r\n    style, width, color, curved, lengthPx,\r\n    startField, endField\r\n  });\r\n\r\n  FLAB.passArm = null;\r\n\r\n  // cleanup\r\n  FLAB.aim.candidateId = FLAB.aim.lockedId = null;\r\n  clearAimTags();\r\n  while (FLAB.previewG?.firstChild) FLAB.previewG.removeChild(FLAB.previewG.firstChild);\r\n}\r\n\r\nexport function updatePassPreview(v) {\r\n  if (!FLAB.passArm?.drawing) return;\r\n  const passer = FLAB.activePlayer;\r\n  if (!passer) return;\r\n\r\n  // Handle null/undefined viewPt\r\n  if (!v || typeof v.x !== 'number' || typeof v.y !== 'number') {\r\n    return;\r\n  }\r\n\r\n  console.debug('[pass] move', v.x|0, v.y|0);\r\n\r\n  // track latest pointer\r\n  FLAB.passArm.latest = v;\r\n\r\n  // ----- aim acquisition -----\r\n  let cand = null;\r\n  if (AIM.enabled) {\r\n    const { player, dist } = nearestPlayerView(v.x, v.y, passer.id);\r\n    if (player && dist <= AIM.radius) cand = player;\r\n  }\r\n\r\n  const now = performance.now();\r\n\r\n  // hysteresis & promotion to lock\r\n  if (cand) {\r\n    if (FLAB.aim.lockedId) {\r\n      const lp = getPlayer(FLAB.aim.lockedId);\r\n      const lpView = getPlayerViewCoords(lp);\r\n      if (lpView) {\r\n        const d = Math.hypot(lpView.x - v.x, lpView.y - v.y);\r\n        if (d > AIM.radius + AIM.hysteresis) {\r\n          FLAB.aim.lockedId = null;\r\n          FLAB.aim.candidateId = cand.id;\r\n          FLAB.aim.showAt = now;\r\n        }\r\n      }\r\n    } else {\r\n      if (FLAB.aim.candidateId !== cand.id) {\r\n        FLAB.aim.candidateId = cand.id;\r\n        FLAB.aim.showAt = now;\r\n      } else if (now - FLAB.aim.showAt >= AIM.delay) {\r\n        FLAB.aim.lockedId = cand.id;\r\n      }\r\n    }\r\n  } else {\r\n    FLAB.aim.candidateId = null;\r\n    FLAB.aim.lockedId = null;\r\n  }\r\n\r\n  // ----- visual rings -----\r\n  clearAimTags();\r\n  if (FLAB.aim.candidateId && !FLAB.aim.lockedId) {\r\n    playerEl(FLAB.aim.candidateId)?.setAttribute('data-aim', 'pre');\r\n  }\r\n  if (FLAB.aim.lockedId) {\r\n    playerEl(FLAB.aim.lockedId)?.setAttribute('data-aim', 'lock');\r\n  }\r\n\r\n  // ----- geometry (halo-edge origin + snapped end if locked) -----\r\n  const haloR = (document.getElementById('flabHalo')?.offsetWidth || 0) / 2;\r\n  const startGap = getVarPx('--pass-origin-gap', 1.5);\r\n  const passerView = getPlayerViewCoords(passer);\r\n  if (!passerView) return;\r\n  const start = insetFromA(passerView.x, passerView.y, v.x, v.y, haloR + startGap);\r\n\r\n  let endX = v.x, endY = v.y;\r\n  const tgtGap = getVarPx('--pass-target-gap', 2);\r\n  const targetR = 28; // jersey visual radius\r\n\r\n  if (FLAB.aim.lockedId) {\r\n    const t = getPlayer(FLAB.aim.lockedId);\r\n    const tView = getPlayerViewCoords(t);\r\n    if (tView) {\r\n      const targetVecX = tView.x - passerView.x;\r\n      const targetVecY = tView.y - passerView.y;\r\n      const targetLenSq = targetVecX ** 2 + targetVecY ** 2;\r\n      if (targetLenSq > 0) {\r\n        const pointerVecX = v.x - passerView.x;\r\n        const pointerVecY = v.y - passerView.y;\r\n        const projection = (pointerVecX * targetVecX + pointerVecY * targetVecY) / targetLenSq;\r\n        if (projection > 1.05) {\r\n          FLAB.aim.lockedId = null;\r\n          FLAB.aim.candidateId = null;\r\n        } else {\r\n          const end = insetFromB(passerView.x, passerView.y, tView.x, tView.y, targetR + tgtGap);\r\n          endX = end.x;\r\n          endY = end.y;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // draw (debug shaft)\r\n  const len = Math.hypot(endX - start.x, endY - start.y);\r\n  setArrowPaths(FLAB.previewG, start, { x: endX, y: endY }, FLAB.passStyle, len, shaftClassFor(FLAB.passStyle));\r\n\r\n  // Finalize head positioning after preview update\r\n  finalizeHead(FLAB.previewG, FLAB.passStyle);\r\n}\r\n\r\n\r\nexport function commitArrow(fromId, point, curved = false, control = null) {\r\n  if (!point) return;\r\n\r\n  // NEW: Use anchor system for entity-based arrow attachment\r\n  // Get locked target from aim state (visual feedback during drag)\r\n  // ONLY snap to player if aim-locked during drag, NOT on proximity\r\n  const lockId = FLAB.aim?.lockedId ?? null;\r\n  const toPlayerId = lockId || null;\r\n\r\n  // Get passer position for metadata\r\n  const passer = getPlayer(fromId);\r\n  const passerEl = getPlayerEl(fromId);\r\n  let startField = null, endField = null;\r\n\r\n  if (passer && passerEl) {\r\n    const passerRect = passerEl.getBoundingClientRect();\r\n    const fieldRect = document.querySelector('.flab-field').getBoundingClientRect();\r\n    const startView = {\r\n      x: passerRect.left + passerRect.width / 2 - fieldRect.left,\r\n      y: passerRect.top + passerRect.height / 2 - fieldRect.top\r\n    };\r\n    startField = viewToField(startView);\r\n\r\n    // For metadata, compute endpoint based on whether arrow is anchored\r\n    let endView = point;\r\n    if (toPlayerId) {\r\n      const targetEl = getPlayerEl(toPlayerId);\r\n      if (targetEl) {\r\n        const rect = targetEl.getBoundingClientRect();\r\n        const fieldRect = document.querySelector('.flab-field').getBoundingClientRect();\r\n        endView = {\r\n          x: rect.left + rect.width / 2 - fieldRect.left,\r\n          y: rect.top + rect.height / 2 - fieldRect.top\r\n        };\r\n      }\r\n    }\r\n    endField = viewToField(endView);\r\n  }\r\n\r\n  // Store comprehensive metadata\r\n  const meta = {\r\n    toId: toPlayerId,\r\n    startInsetPx: getVarPx('--pass-origin-gap', 1.5) + haloRadiusPx(),\r\n    endInsetPx: getVarPx('--pass-target-gap', 2) + (toPlayerId ? tokenRadiusPx(getPlayerEl(toPlayerId)) : 0),\r\n    headInsetPx: 16, // arrowhead clearance\r\n    startField,\r\n    endField,\r\n    createdAt: performance.now()\r\n  };\r\n\r\n  // Create arrow with NEW entity-anchored structure\r\n  const passId = FLAB.arrowCounter++;\r\n  const arrow = createArrowObject(fromId, toPlayerId, point, curved, control);\r\n  arrow.id = passId;\r\n  arrow.meta = meta;\r\n\r\n  FLAB.arrows.push(arrow);\r\n\r\n  // Remember last committed pass for \"Play Last\" functionality\r\n  FLAB.lastPassId = passId;\r\n\r\n  // Clear aim state after commit\r\n  clearAimTags();\r\n\r\n  // Import and call renderArrows\r\n  import('./render.js').then(({ renderArrows }) => {\r\n    renderArrows();\r\n  });\r\n\r\n  // Highlight the new pass\r\n  setTimeout(() => highlightPass(passId), 100);\r\n\r\n  // Save state for undo\r\n  saveUndoState(`Add pass from player ${fromId}`);\r\n}\r\n\r\nexport async function renderArrows() {\r\n  const svgRoot = getArrowSvg();\r\n  if (!svgRoot) return;\r\n\r\n  // Get the arrow-group that has the transforms and clipping\r\n  const arrowGroup = document.getElementById('arrow-group');\r\n  if (!arrowGroup) {\r\n    console.warn('renderArrows: #arrow-group not found');\r\n    return;\r\n  }\r\n\r\n  // Clear existing arrows (except markers in defs)\r\n  const existingPasses = arrowGroup.querySelectorAll('.svg-pass');\r\n  existingPasses.forEach(el => el.remove());\r\n\r\n  // NEW: Migrate all arrows to new entity-anchored format on first render\r\n  // This ensures backward compatibility with old stored arrows\r\n  if (FLAB.arrows && FLAB.arrows.length > 0) {\r\n    const { migrateArrow } = await import('./arrow-anchor.js');\r\n    FLAB.arrows = FLAB.arrows.map(arrow => {\r\n      const migrated = migrateArrow(arrow);\r\n      if (!migrated.to || migrated.to.playerId === undefined) {\r\n        console.log(`\u26A1 Migrated arrow #${arrow.id} to new anchor format`);\r\n      }\r\n      return migrated;\r\n    });\r\n  }\r\n\r\n  // Create all arrows with NEW entity-anchored system\r\n  const promises = FLAB.arrows.map(arrow => createPass(arrow));\r\n\r\n  Promise.all(promises).then(groups => {\r\n    groups.forEach(group => {\r\n      if (group) {\r\n        // Append to arrow-group, not svgRoot, to inherit transforms\r\n        arrowGroup.appendChild(group);\r\n        // Finalize head positioning after creation\r\n        finalizeHead(group, FLAB.passStyle);\r\n      }\r\n    });\r\n\r\n    // Force update all shaft colors after rendering\r\n    forceUpdateAllShaftColors();\r\n  });\r\n\r\n  document.getElementById(\"arrow-layer\")?.classList.toggle(\"is-interactive\", FLAB.mode === \"erase\");\r\n}\r\n\r\n// Force update all shaft colors - DIRECT SVG attribute approach\r\nfunction forceUpdateAllShaftColors() {\r\n  // Get color from multiple sources in priority order\r\n  let currentColor = '#ffd166'; // fallback\r\n\r\n  // Try CSS variable first\r\n  const cssVar = getComputedStyle(document.documentElement).getPropertyValue('--pass-color').trim();\r\n  if (cssVar) {\r\n    currentColor = cssVar;\r\n  }\r\n\r\n  // Try PASS.color if available\r\n  if (PASS?.color) {\r\n    currentColor = PASS.color;\r\n  }\r\n\r\n  const allShafts = document.querySelectorAll('.pass-shaft');\r\n  console.log(`\uD83D\uDD27 Force updating ${allShafts.length} shaft colors to: ${currentColor} (CSS: ${cssVar}, PASS: ${PASS?.color})`);\r\n\r\n  allShafts.forEach((shaft, index) => {\r\n    console.log(`\uD83D\uDD27 Updating shaft ${index + 1}:`);\r\n    console.log(`  - Before: stroke=\"${shaft.getAttribute('stroke')}\", style.stroke=\"${shaft.style.stroke}\"`);\r\n\r\n    // NUCLEAR OPTION: Use both SVG attribute AND inline style\r\n    shaft.setAttribute('stroke', currentColor);\r\n    shaft.style.stroke = currentColor;  // Inline style has highest specificity - nothing can override this\r\n    shaft.style.color = currentColor;\r\n    shaft.setAttribute('color', currentColor);\r\n\r\n    console.log(`  - After: stroke=\"${shaft.getAttribute('stroke')}\", style.stroke=\"${shaft.style.stroke}\"`);\r\n\r\n    // Check computed style after update\r\n    setTimeout(() => {\r\n      const computed = getComputedStyle(shaft).stroke;\r\n      console.log(`  - Computed after 100ms: ${computed}`);\r\n    }, 100);\r\n  });\r\n}\r\n\r\n// Pass clearing functions for erase menu\r\nexport function clearLastPass() {\r\n  const arr = FLAB.arrows || [];\r\n  if (arr.length > 0) {\r\n    arr.pop();\r\n    console.log('Cleared last pass');\r\n    // Save state for undo\r\n    saveUndoState('Delete last pass');\r\n  }\r\n}\r\n\r\nexport function clearAllPasses() {\r\n  FLAB.arrows = [];\r\n  console.log('Cleared all passes');\r\n  // Save state for undo\r\n  saveUndoState('Clear all passes');\r\n}\r\n\r\nexport function initPassTool() {\r\n  const arrowLayer = document.getElementById(\"arrow-layer\");\r\n  if (!arrowLayer) {\r\n    console.error('Cannot initialize pass tool: #arrow-layer not found');\r\n    return;\r\n  }\r\n\r\n  // Create/clear a dedicated preview group\r\n  if (!FLAB.previewGroup) {\r\n    FLAB.previewGroup = ensureGroup('pass-preview');\r\n  } else {\r\n    // purge previous children\r\n    while (FLAB.previewGroup.firstChild) FLAB.previewGroup.removeChild(FLAB.previewGroup.firstChild);\r\n    // reattach in case it got detached\r\n    FLAB.previewGroup = ensureGroup('pass-preview');\r\n  }\r\n\r\n  // Handle arrow layer clicks for erase mode\r\n  arrowLayer.addEventListener(\"pointerdown\", evt => {\r\n    if (FLAB.mode !== \"erase\") return;\r\n\r\n    const target = evt.target.closest('.svg-pass');\r\n    if (!target) return;\r\n\r\n    const arrowId = target.getAttribute('data-arrow-id');\r\n    if (arrowId) {\r\n      evt.preventDefault();\r\n      evt.stopPropagation();\r\n\r\n      FLAB.arrows = FLAB.arrows.filter(item => item.id !== parseInt(arrowId));\r\n      renderArrows();\r\n    }\r\n  });\r\n}\r\n\r\n// Pass data getters for animation module - SINGLE SOURCE OF TRUTH\r\nexport function getShaftPathForPass(passId) {\r\n  // Get the ACTUAL visible shaft path that users see\r\n  return document.querySelector(`#arrow-group [data-arrow-id=\"${passId}\"] .pass-shaft`) ||\r\n         document.querySelector(`#arrow-group [data-arrow-id=\"${passId}\"] path`) ||\r\n         document.querySelector(`#arrow-layer [data-arrow-id=\"${passId}\"] path`);\r\n}\r\n\r\nexport function getPassInsets(pass) {\r\n  const m = pass.meta || {};\r\n  return {\r\n    startInsetPx: m.startInsetPx ?? 18,\r\n    endInsetPx: (m.endInsetPx ?? 18) + (m.headInsetPx ?? 16)\r\n  };\r\n}\r\n\r\nexport function highlightPass(passId) {\r\n  // Remove existing highlights\r\n  document.querySelectorAll('#arrow-group [data-arrow-id].is-selected')\r\n    .forEach(el => el.classList.remove('is-selected'));\r\n\r\n  // Add highlight to selected pass\r\n  document.querySelectorAll(`#arrow-group [data-arrow-id=\"${passId}\"]`)\r\n    .forEach(el => el.classList.add('is-selected'));\r\n}\r\n\r\nexport function getPassPathNode(passId) {\r\n  return getShaftPathForPass(passId);\r\n}\r\n\r\nexport function getPassMeta(passId) {\r\n  const arrow = FLAB.arrows.find(a => a.id.toString() === passId.toString());\r\n  if (!arrow) return null;\r\n\r\n  return {\r\n    id: arrow.id.toString(),\r\n    fromId: arrow.fromId,\r\n    toId: arrow.toId || null,\r\n    curved: arrow.curved || false,\r\n    style: FLAB.passStyle,\r\n    width: FLAB.passWidth,\r\n    color: PASS.color || '#ffd166'\r\n  };\r\n}\r\n\r\nexport function getLastPassId() {\r\n  const arrows = FLAB.arrows;\r\n  return arrows.length > 0 ? arrows[arrows.length - 1].id.toString() : null;\r\n}\r\n\r\nexport function getAllPassIds() {\r\n  return FLAB.arrows.map(arrow => arrow.id.toString());\r\n}\r\n\r\nexport function clearPassHighlight() {\r\n  // Remove highlight from all passes\r\n  const highlighted = document.querySelectorAll('#arrow-group [data-arrow-id].is-selected');\r\n  highlighted.forEach(el => el.classList.remove('is-selected'));\r\n}\r\n\r\n// Head diagnostics for debugging\r\nexport function logHeadDiagnostics(){\r\n  const rows = [...document.querySelectorAll('#arrow-layer path.pass-shaft')].map(p=>{\r\n    const L = p.getTotalLength();\r\n    const hb = Number(p.dataset.headBaseLen ?? L);\r\n    const head = p.parentNode.querySelector('.pass-head');\r\n    const t = head?.getAttribute('transform') || '';\r\n    const sw = parseFloat(getComputedStyle(p).strokeWidth);\r\n    return {\r\n      L: +L.toFixed(1),\r\n      headBase: +hb.toFixed(1),\r\n      gap: +(L - hb).toFixed(2),\r\n      sw,\r\n      transform: t.slice(0,80)\r\n    };\r\n  });\r\n  console.table(rows);\r\n}\r\n\r\n// Force refresh all existing arrows with current color\r\nexport function forceArrowRefresh() {\r\n  const currentColor = PASS?.color || getComputedStyle(document.documentElement).getPropertyValue('--pass-color').trim() || '#ffd166';\r\n\r\n  // Force CSS variable update\r\n  document.documentElement.style.setProperty('--pass-color', currentColor);\r\n\r\n  import('../assets/arrows/simple-markers.js')\r\n    .then(({ updateMarkerColors }) => updateMarkerColors?.(currentColor))\r\n    .catch(error => console.warn('updateMarkerColors import failed', error));\r\n\r\n  // Force recalculation on all existing shaft elements\r\n  const allShafts = document.querySelectorAll('.pass-shaft');\r\n  allShafts.forEach(shaft => {\r\n    shaft.setAttribute('stroke', currentColor);\r\n    shaft.style.stroke = currentColor;\r\n    shaft.style.color = currentColor;\r\n    shaft.setAttribute('color', currentColor);\r\n    // Force immediate style recalculation\r\n    getComputedStyle(shaft).stroke;\r\n  });\r\n\r\n  console.log(`\uD83C\uDFA8 Forced refresh of ${allShafts.length} arrow shafts with color: ${currentColor}`);\r\n}\r\n\r\n// Re-export the marker rebuilding function\r\nexport { rebuildAllMarkers };\r\n\r\nwindow.__mod_pass = true;\r\n\r\n"],
  "mappings": "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",
  "names": ["FLAB", "AIM", "headSpec", "PASS", "HEAD_OVERLAP", "centerInField", "fieldSize", "clipSegmentToRect", "insetFromA", "insetFromB", "viewToField", "playerEl", "clearAimTags", "ensureHeadMarker", "rebuildAllMarkers", "headPxFor", "headTrimPx", "getArrowSvg", "ensureGroup", "logPass", "saveUndoState", "createArrowObject", "getArrowStart", "getArrowEnd", "getVarPx", "varName", "fallback", "val", "__name", "SVG_NS", "PASS_STYLES", "safeNumber", "v", "def", "n", "headOverlapFor", "style", "attachPassHead", "shaftPath", "L", "overlap", "baseLen", "attachHead", "result", "error", "ensurePassMarker", "svg", "preloadArrowHeads", "finalizeHead", "passGroup", "shaft", "oldHead", "unit", "ax", "ay", "bx", "by", "dx", "dy", "d", "getPlayer", "playerId", "player", "getPlayerEl", "snapHalf", "p", "haloRadiusPx", "tokenRadiusPx", "el", "r", "getPlayerViewCoords", "rect", "fieldRect", "nearestPlayerView", "x", "y", "excludeId", "best", "bestDist", "pView", "computePassEndpoints", "passerEl", "targetEl", "startGap", "endGap", "A0", "B0", "startInset", "endInset", "A", "B", "ux", "uy", "minLen", "cx", "cy", "half", "computeClippedPass", "w", "h", "seg", "applyPassStyle", "lengthPx", "s", "cls", "defs", "markerId", "setArrowPaths", "svgGroup", "Btip", "styleKey", "lenPx", "shaftClass", "svgRoot", "arrowGroup", "headId", "headPx", "trim", "Bshaft", "child", "mainShaft", "currentColor", "cssVar", "monitorCount", "monitorChanges", "actualStroke", "computedStroke", "hasStyleStroke", "observer", "mutations", "mutation", "createPass", "arrow", "id", "fromId", "to", "curved", "control", "arrowStart", "arrowEnd", "tempTarget", "pathData", "safeControlX", "safeControlY", "clipped", "group", "hitbox", "beginPassPreview", "passer", "shaftClassFor", "commitPass", "cur", "tgtGap", "passerView", "endV", "t", "tView", "commitArrow", "startField", "endField", "width", "color", "fromNum", "lockedId", "target", "toId", "toNum", "updatePassPreview", "cand", "dist", "now", "lp", "lpView", "haloR", "start", "endX", "endY", "targetR", "targetVecX", "targetVecY", "targetLenSq", "pointerVecX", "pointerVecY", "end", "len", "point", "toPlayerId", "passerRect", "startView", "endView", "meta", "passId", "renderArrows", "highlightPass", "migrateArrow", "migrated", "promises", "groups", "forceUpdateAllShaftColors", "allShafts", "index", "computed", "clearLastPass", "arr", "clearAllPasses", "initPassTool", "arrowLayer", "evt", "arrowId", "item", "getShaftPathForPass", "getPassInsets", "pass", "m", "getPassPathNode", "getPassMeta", "a", "getLastPassId", "arrows", "getAllPassIds", "clearPassHighlight", "logHeadDiagnostics", "rows", "hb", "sw", "forceArrowRefresh", "updateMarkerColors"]
}
